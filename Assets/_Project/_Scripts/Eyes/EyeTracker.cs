using System.Collections;using System.Collections.Generic;using UnityEngine;using UnityEngine.Serialization;using Gilzoide.UpdateManager;public class EyeTracker : AManagedBehaviour, IUpdatable{    private MonsterBase _monsterBase;    public GameObject target = null;    [SerializeField] GameObject pupil;    public float offMod;    public float offMax;    private float offSetFromCenter = 0f;    private Vector3 initialPos;    private Vector3 initialRot;    [SerializeField] private bool canTrack = false;     void Start()    {        //Get and save the initial position of the _pupil.        //_pupil.transform.localPosition;        //Save the _pupil's initial rotation.        initialRot = pupil.transform.eulerAngles;        initialPos = pupil.transform.localPosition;        //target = GameManager.Instance.playerRef.gameObject;        target = GameManager.Instance.playerRef.gameObject;        _monsterBase = GetComponent<MonsterBase>();    }            //This function exists outside of FixedUpdate just in case we want to do something that changes how this affects eyeballs vs pupils    //i.e. if we want the eyeballs to be affected by their distance to the center of the head, in addition to the other modifiers    void SetOffSet(){        initialPos = this.transform.position;        float distTar = Vector3.Distance(pupil.transform.position, target.transform.position);        offSetFromCenter = EaseInQuad(0f, offMax, distTar * offMod);        offSetFromCenter = Mathf.Clamp(offSetFromCenter, 0, offMax);    }    private static float EaseInQuad(float start, float end, float value){            end -= start;            return end * value * value + start;    }        public void ToggleTrackTarget(bool track, GameObject newTarget)    {        canTrack = track;        if(track)            target = newTarget;    }    public void TrackTarget(bool canTrack)    {        this.canTrack = canTrack;    }    public void ManagedUpdate()    {        if (target != null && _monsterBase && canTrack)        {            //Debug.Log("Tracking");            Vector3 dir = (target.transform.position - pupil.transform.position).normalized;            pupil.transform.position = Vector2.Lerp(pupil.transform.position, transform.position + dir, Time.deltaTime *15);        }        else        {            //lerp back to identity            pupil.transform.localPosition = Vector2.Lerp(pupil.transform.localPosition, Vector3.up * 0.6f, Time.deltaTime);            pupil.transform.localRotation = Quaternion.identity;        }    }    }